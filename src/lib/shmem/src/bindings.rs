/* automatically generated by rust-bindgen 0.60.1 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(improper_ctypes)]

pub type size_t = ::std::os::raw::c_ulong;
pub type __uint32_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn buddy_goodPoolSizeNBytes(requested_nbytes: u32) -> u32;
}
extern "C" {
    pub fn buddy_metaSizeNBytes(pool_nbytes: u32) -> size_t;
}
extern "C" {
    pub fn buddy_poolInit(pool: *mut ::std::os::raw::c_void, pool_nbytes: size_t);
}
extern "C" {
    pub fn buddy_metaInit(
        meta: *mut ::std::os::raw::c_void,
        pool: *const ::std::os::raw::c_void,
        pool_nbytes: u32,
    );
}
extern "C" {
    pub fn buddy_alloc(
        requested_nbytes: size_t,
        meta: *mut ::std::os::raw::c_void,
        pool: *mut ::std::os::raw::c_void,
        pool_nbytes: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn buddy_free(
        p: *mut ::std::os::raw::c_void,
        meta: *mut ::std::os::raw::c_void,
        pool: *mut ::std::os::raw::c_void,
        pool_nbytes: size_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ShMemFile {
    pub p: *mut ::std::os::raw::c_void,
    pub nbytes: size_t,
    pub name: [::std::os::raw::c_char; 255usize],
}
#[test]
fn bindgen_test_layout__ShMemFile() {
    assert_eq!(
        ::std::mem::size_of::<_ShMemFile>(),
        272usize,
        concat!("Size of: ", stringify!(_ShMemFile))
    );
    assert_eq!(
        ::std::mem::align_of::<_ShMemFile>(),
        8usize,
        concat!("Alignment of ", stringify!(_ShMemFile))
    );
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ShMemFile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ShMemFile),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
    fn test_field_nbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ShMemFile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nbytes) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_ShMemFile),
                "::",
                stringify!(nbytes)
            )
        );
    }
    test_field_nbytes();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ShMemFile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_ShMemFile),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
pub type ShMemFile = _ShMemFile;
extern "C" {
    pub fn shmemfile_alloc(nbytes: size_t, shmf: *mut ShMemFile) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shmemfile_map(
        name: *const ::std::os::raw::c_char,
        nbytes: size_t,
        shmf: *mut ShMemFile,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shmemfile_unmap(shmf: *mut ShMemFile) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shmemfile_free(shmf: *mut ShMemFile) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shmemfile_goodSizeNBytes(requested_nbytes: size_t) -> size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ShMemAllocator {
    _unused: [u8; 0],
}
pub type ShMemAllocator = _ShMemAllocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ShMemSerializer {
    _unused: [u8; 0],
}
pub type ShMemSerializer = _ShMemSerializer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ShMemBlock {
    pub p: *mut ::std::os::raw::c_void,
    pub nbytes: size_t,
}
#[test]
fn bindgen_test_layout__ShMemBlock() {
    assert_eq!(
        ::std::mem::size_of::<_ShMemBlock>(),
        16usize,
        concat!("Size of: ", stringify!(_ShMemBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<_ShMemBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(_ShMemBlock))
    );
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ShMemBlock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ShMemBlock),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
    fn test_field_nbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ShMemBlock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nbytes) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_ShMemBlock),
                "::",
                stringify!(nbytes)
            )
        );
    }
    test_field_nbytes();
}
pub type ShMemBlock = _ShMemBlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ShMemBlockSerialized {
    pub offset: size_t,
    pub nbytes: size_t,
    pub block_nbytes: size_t,
    pub name: [::std::os::raw::c_char; 255usize],
}
#[test]
fn bindgen_test_layout__ShMemBlockSerialized() {
    assert_eq!(
        ::std::mem::size_of::<_ShMemBlockSerialized>(),
        280usize,
        concat!("Size of: ", stringify!(_ShMemBlockSerialized))
    );
    assert_eq!(
        ::std::mem::align_of::<_ShMemBlockSerialized>(),
        8usize,
        concat!("Alignment of ", stringify!(_ShMemBlockSerialized))
    );
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ShMemBlockSerialized>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ShMemBlockSerialized),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_nbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ShMemBlockSerialized>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nbytes) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_ShMemBlockSerialized),
                "::",
                stringify!(nbytes)
            )
        );
    }
    test_field_nbytes();
    fn test_field_block_nbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ShMemBlockSerialized>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).block_nbytes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_ShMemBlockSerialized),
                "::",
                stringify!(block_nbytes)
            )
        );
    }
    test_field_block_nbytes();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ShMemBlockSerialized>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_ShMemBlockSerialized),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
pub type ShMemBlockSerialized = _ShMemBlockSerialized;
extern "C" {
    pub fn shmemallocator_getGlobal() -> *mut ShMemAllocator;
}
extern "C" {
    pub fn shmemserializer_getGlobal() -> *mut ShMemSerializer;
}
extern "C" {
    pub fn shmemallocator_create() -> *mut ShMemAllocator;
}
extern "C" {
    pub fn shmemallocator_destroy(allocator: *mut ShMemAllocator);
}
extern "C" {
    pub fn shmemallocator_destroyNoShmDelete(allocator: *mut ShMemAllocator);
}
extern "C" {
    pub fn shmemallocator_alloc(allocator: *mut ShMemAllocator, nbytes: size_t) -> ShMemBlock;
}
extern "C" {
    pub fn shmemallocator_free(allocator: *mut ShMemAllocator, blk: *mut ShMemBlock);
}
extern "C" {
    pub fn shmemallocator_blockSerialize(
        allocator: *mut ShMemAllocator,
        blk: *mut ShMemBlock,
    ) -> ShMemBlockSerialized;
}
extern "C" {
    pub fn shmemallocator_blockDeserialize(
        allocator: *mut ShMemAllocator,
        serial: *mut ShMemBlockSerialized,
    ) -> ShMemBlock;
}
extern "C" {
    pub fn shmemserializer_create() -> *mut ShMemSerializer;
}
extern "C" {
    pub fn shmemserializer_destroy(serializer: *mut ShMemSerializer);
}
extern "C" {
    pub fn shmemserializer_blockSerialize(
        serializer: *mut ShMemSerializer,
        blk: *mut ShMemBlock,
    ) -> ShMemBlockSerialized;
}
extern "C" {
    pub fn shmemserializer_blockDeserialize(
        serializer: *mut ShMemSerializer,
        serial: *const ShMemBlockSerialized,
    ) -> ShMemBlock;
}
extern "C" {
    pub fn shmem_util_uintLog2(v: u32) -> u32;
}
